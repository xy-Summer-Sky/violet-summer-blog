---
title: 算法刷题
published: 2025-05-19
description: 在牛客网、力扣和卡玛网刷题记录，用于工作或者复试笔试
tags:
  - 算法
category: algorithm
draft: true
image: /violet.png
---
# 场景问题

## 内存一致性问题

### 场景

嗯，我现在需要解决的是两个内存区域保持数据一致性的问题。用户提到之前的方法是让两个内存块都持有指向同一块内存的指针，但这种方法可能有问题。我得仔细想想为什么这个方案欠妥，然后找一个更完善的解决方案。
首先，原来的方案是两个内存块都有指针指向同一个地方。假设这两个指针都指向同一个对象，那么当修改那个对象时，这两个指针指向的内容自然都会变，对吧?但可能用户遇到的问题不是这样，可能这两个指针本身被修改了，比如重新指向其他地方，这样就会导致两个内存块中的指针不再同步。比如，假设内存块A和B各自保存-个指针，指向同一个数据对象。如果通过内存块A的指针修改了数据，那么通过B的指针访问时，数据应该已经改变，这没问题，但如果其中一个指针被重新指向另一个地址，另一个指针并不会跟着变，这时候两个内存块中的指针就不一致了。这可能就是原方案的缺陷,

### 解决

问题在于：**两个内存块只是各自保存了一个指针，这两个指针本身是独立的**。一旦有一方把自己的指针指向了新的内存区域，另一方并不会感知到这种变化，导致数据不一致。

#### 主要问题


- 指针本身的变动不会同步。
- 只同步了“内容”，没有同步“指向关系”。

#### 1. 使用“间接指针”或“指针的指针”

让两个内存块都持有**指向同一个指针的指针**（即二级指针），这样只要这个指针被修改，所有持有指针的地方都能感知到变化。

**示例：**
```cpp

int *data = new int(42);   // 实际数据
int **pA = &data;          // A持有指向data的指针的指针
int **pB = &data;          // B也持有指向data的指针的指针

// 修改指针指向
* pA = new int(100);       // 改变指针指向
// 此时pB看到的也是新地址

// 访问数据
std::cout << **pA << std::endl;
std::cout << **pB << std::endl;

```

#### 2. 使用智能指针（如 `std::shared_ptr`）

C++11 及以上推荐用 `std::shared_ptr`，这样多个对象可以共享同一份数据和生命周期管理。

**示例：**
```cpp
int main() {
    auto data = std::make_shared<int>(42);
    std::shared_ptr<int> a = data;
    std::shared_ptr<int> b = data;

    // 修改数据
    *a = 100;

    std::cout << *a << std::endl; // 100
    std::cout << *b << std::endl; // 100

    // 如果要让a和b都能感知“指向对象”的变化，可以用shared_ptr<shared_ptr<T>>
    // 但一般业务场景下，直接共享数据即可
    return 0;
}

```


